# Lab 4

{% hint style="danger" %}
**Warning: Live Malware Handling**

This lab involves working with live malware samples provided via Docker containers. While it is rare for these samples to escape the container and compromise the host system, the risk still exists. To minimize potential harm, we strongly recommend performing this lab's exercises within a virtual machine (VM). We suggest using a Linux VM with Docker installed, such as Kali Linux or Ubuntu. For instructions on setting up your VM, please refer to the [following guide](https://uwacyber.gitbook.io/cits1003/cits1003-labs/lab-1-setting-up-your-laptop).
By isolating the lab environment within a VM, you can prevent any accidental damage to your primary operating system and files.

{% endhint %}

This lab will explore virus detection through the use of two different tools: YARA and VirusTotal.

YARA is an open-source tool designed to help malware researchers identify and classify malware samples. It allows users to create descriptions (or rules) for malware families based on textual and/or binary patterns. YARA is multi-platform, running on Linux, Windows, and Mac OS X, and can be used through its command-line interface or from Python scripts with the YARA-Python extension.

VirusTotal is an online service that analyzes suspicious files and URLs to detect types of malware, including viruses, worms, and trojans. It uses a variety of tools, including YARA, to identify potential threats. VirusTotal also provides an API that allows users to automate the scanning process and integrate VirusTotal's capabilities into their own applications.

Requirements for this lab:

- A virtual machine (VM) with Linux installed (e.g., Kali Linux or Ubuntu)
- Docker installed on the VM
- A [VirusTotal account](https://www.virustotal.com/gui/join-us)

In your VM, pull and run the Docker container that we will use for the lab:

```
sudo docker run -it -rm docker_image:placeholder
```

{% hint style="info" %}
The use of YARA necessitates some understanding of concepts such as hex encodings and (to a lesser extent) regular expressions (regex). A few references you may find useful:
* [Hexadecimals](https://byjus.com/maths/hexadecimal-number-system/#:~:text=The%20hexadecimal%20number%20system%20is,digit%20represents%20a%20decimal%20value.)
* [Regular expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions)
{% endhint %}



---

## 1. YARA

YARA is a tool used to identify and classify malware samples by creating descriptions of malware families based on textual or binary patterns. YARA rules are essentially a set of strings and a Boolean expression that determines the logic of the rule. You may be famliiar with YARA from the CITS1003 course; we will expand upon that understanding by exploring more complex YARA rule writing, utilizing advanced string matching techniques and conditional logic to detect malware.

The key components of a YARA rule are:

- **Meta section:** Contains metadata about the rule like author, description, reference, etc. This information is not used for matching but provides context.
- **Strings section:** Defines the strings to search for, which can be text strings, hexadecimal strings, or regular expressions.
- **Condition section:** Contains the Boolean expression that determines if a rule matches or not based on the presence of the defined strings.

A YARA rule file (.yar) can contain multiple rules. To use the rules, you provide the rule file and target (file, directory, process) to the YARA command line tool.

We'll begin with a simple yara file example. Create a file called `rules.yar` in the `/opt` directory and fill it with the following content:

```
rule hello_world
{
	meta:
        description = "basic yara file"
        author = "CITS2006"
	strings:
	   $hello = "hello, world!"
	condition:
	   $hello
}
```

The file contains a simple YARA rule named `hello_world`. The strings section defines the strings to search for. Here, we have a single text string `$hello` which contains the literal `"hello, world!"`. The `$` prefix denotes a string identifier. Text strings can be case-sensitive and are enclosed in double quotes. The condition section specifies the logic that determines if the rule matches. In this simple example, the condition is just `$hello`, meaning the rule will match any file or data that contains the literal string "hello, world!".

Let's create a few more rules.

### Basic Strings and Conditions

We can create rules that aim to detect files containing specific text, binary, and regex patterns. In addition to the `hello_world` rule, add a new rule called `strings_example`:

```
rule hello_world
{
	meta:
        description = "basic yara file"
        author = "CITS2006"
	strings:
	   $hello = "hello, world!"
	condition:
	   $hello
}

rule strings_example {
    strings:
        $my_text_string = "text here"
        $my_hex_string = { E2 34 A1 C8 23 FB }
        $my_regex_string = /user\d{4}/ nocase

    condition:
        $my_text_string or $my_hex_string or $my_regex_string
}
```

We Here's a breakdown of its components:

**Strings Section:**

- `$my_text_string`: Searches for the exact text string "text here". This is a case-sensitive ASCII string.

- `$my_hex_string`: Matches the specific byte sequence E2 34 A1 C8 23 FB. This is useful for identifying unique binary signatures in malware. The curly braces signify the definition of a hexadecimal string in YARA.

- `$my_regex_string`: Uses a [regular expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions) to find patterns matching "user" followed by exactly 4 digits, case-insensitive. Regexes allow for flexible pattern matching. The `nocase` modifier makes the search case-insensitive. Other modifiers like `wide`, `ascii`, and `fullword` provide even more options.

{% hint style="info" %}
For a comprehensive documentation of the modifiers and their usage, check out the [YARA documentation](https://yara.readthedocs.io/en/stable/writingrules.html#strings).
{% endhint %}

**Condition Section:**

- `$my_text_string or $my_hex_string or $my_regex_string`: The rule will match if any of the three strings defined earlier are found in the target file. This condition provides three possible indicators of malware and will trigger a match if any one is present. More complex conditions can be crafted using a variety of operators and functions. An analyst could use a rule like this as a starting point, iteratively adding more strings and conditions as they uncover additional malware characteristics. For example, the rule could be expanded to also check for specific file sizes, target certain file types, or require a minimum number of string matches. By combining multiple strings and conditions, YARA rules can be made very specific to a particular malware family.

### Running `.yar` Files

To use a YARA file containing defined rules for identifying suspect files, you can execute the following command over a given target location:

```
yara rules.yar ./files
```

This command runs the `rules.yar` file on the `files` subdirectory. The output will show any files that match the rules defined in `rules.yar`, as well as the detecting rule itself.

### Task 1.1 Starting Out!~

Try running your `rules.yar` file on the `/opt/test` subdirectory. What outputs do you get? Inspect the files within the `/opt/test` and ensure that your rules are working as you'd expect.

### Task 1.2: Searching over Multiple Directories

The YARA command-line tool also allows for the application of the YARA file over multiple nested subdirectories in a recursive manner. For this task, you will need to parameterize the yara command line input to allow it to scan directories recursively.

First, note your output from the previous task. Now, adjust your command to scan through the `/opt/test` subdirectory recursively. What do you now get as the output?

### String Wildcards and Hex String Variations

In addition to basic strings and conditions, YARA provides a variety of advanced features for creating more targeted and effective rules. Let's explore some of these.

When defining hex strings in YARA, you can use wildcards and specify byte ranges or alternatives to make your rules more flexible. Here are some examples:

```
$a={5C 70 68 6F 74 6F 2E 70 6E 67}
```

This defines a hex string that matches the exact byte sequence. Note the use of curly brackets instead of quotation marks.

```
$a={5C 70 68 6F ?? ?F 2E 70 6E 67}
```

In this example, the question marks `(?)` are used as wildcards. They will match any single byte in that position. This is useful if you've detected a slight variation of a hex pattern across multiple samples.

```
$a={5C [2-10] 6F 74 6F 2E 70 6E 67}
```

Here, `[2-10]` specifies a range of possible byte values. This rule will match if the string starts with `5C`, is followed by any 2 to 10 bytes, and then continues with the rest of the specified hex sequence.

```
$a={5C (01 02 | 03 04) 6F 2E 70 6E 67}
```

The `(01 02 | 03 04)` syntax allows for specifying alternative byte sequences. This rule will match if the bytes after `5C` are either `01 02` or `03 04`.

These techniques give you a lot of flexibility in defining hex strings that can match variations of a specific pattern, which is often necessary when dealing with malware that may employ basic obfuscation or mutation techniques.

### More Conditionals

YARA provides a few aliases for convenience in writing rules. For example, try replacing the condition `$my_text_string or $my_hex_string or $my_regex_string` in the `rules.yar` file with the condition `any of them`. This will instruct YARA to match any of the defined strings. Similarly, `all of them` is equivalent to `$my_text_string and $my_hex_string and $my_regex_string`, requiring all strings to be present in the file for a match to occur.

We can also customize how many matches need to be triggered as a condition for the rule to return what it deems a successful condition. Examples include:

- `any of them`: This condition will match if any of the defined strings are found in the target file.
- `all of them`: This condition requires all defined strings to be present in the file for a match to occur.
- `2 of ($a, $b, $c)`: This condition will return a match if any two of the strings `$a`, `$b` or `$c` are found.
- `3 of them`: This condition will match if at least three of the defined strings are found in the target file.
- `$a and not $b`: This condition will match if string `$a` is found, but string `$b` is not found in the target file.
- `4 of ($a*)`: This condition will match if at least four strings matching the pattern `$a*` are found. The `*` is a wildcard that matches any string starting with `$a`.

### File Signatures

Malware often uses specific system commands or has unique file signatures. These can be incorporated into YARA rules for more accurate detection. File headers can be checked to identify specific file types. This is done by looking at the "magic bytes" at the beginning of the file. These bytes are specific sequences that identify the file format. For instance, to detect a Windows PE executable, you could use:

```
condition:
    uint16(0) == 0x5A4D
```

This condition checks if the first two bytes of the file are "MZ" (0x5A4D), which is the signature for a PE file. PE (Portable Executable) is the file format used for executables, object code, and DLLs (dynamic-link libraries) in Windows operating systems. It is a data structure that encapsulates the information necessary for the Windows OS loader to manage the wrapped executable code. This includes dynamic library references for linking, API export and import tables, resource management data and thread-local storage (TLS) data. A PE file consists of a number of headers and sections that tell the dynamic linker how to map the file into memory.

The concept of magic bytes applies to many other file formats as well. Each format has its own unique magic bytes that appear at the beginning of the file. Here are some examples:

- ELF (Executable and Linkable Format) files (used on Linux and other Unix-like systems):
  - `uint32(0) == 0x7F454C46`
- Mach-O (Macintosh Object) files (used on macOS):
  - `uint32(0) == 0xfeedface or uint32(0) == 0xcefaedfe or uint32(0) == 0xfeedfacf or uint32(0) == 0xcffaedfe or uint32(0) == 0xcafebabe or uint32(0) == 0xbebafeca`
- Java class files:
  - `uint32(0) == 0xCAFEBABE`
- PDF files:
  - `uint32(0) == 0x25504446` (which corresponds to the ASCII characters "%PDF")
- ZIP files:
  - `uint32(0) == 0x504B0304` (which corresponds to the ASCII characters "PK\x03\x04")
- PNG files:
  - `uint64(0) == 0x89504E470D0A1A0A` (which corresponds to the ASCII characters "\x89PNG\r\n\x1A\n")

You can also apply these conditions in an exclusionary way. The following condition will not match with any such PE files.

```
uint16(0) != 0x5A4D
```

In addition, we can also specify the file size of the files we are matching. This can be done in a few ways:

- `(filesize > 512)` matches files that are larger than 512 bytes.
- `(filesize < 5000000)` match files that are smaller than 5,000,000 bytes (about 4.77 MB).
- `(filesize < 5MB)` explicitly denotes the file size in megabytes (other suffixes such as `KB` and `GB` will also work)
- `(filesize < 1000KB or filesize > 3000KB)` matches files that are smaller than 1000KB and larger than 3000KB.

These conditions allow us to identify suspicious files. For example, a malware author might attempt to disguise a malicious executable as a harmless PDF file by changing the file extension from `.exe` to `.pdf`. However, if the magic bytes at the beginning of the file still match the PE signature (0x5A4D), a YARA rule can detect this discrepancy.

### Task 1.3. Masquerading Files?

Write a rule that matches files that start with the PE magic bytes (indicating an executable), are less than 1MB in size and have a filename ending in .pdf (you might have to search up how to write this last condition). Such a file may be highly suspicious, as it claims to be a PDF (based on the extension) but is actually an executable. This technique of disguising malware as a benign file type is common and can be effectively detected using YARA rules that check for inconsistencies between the claimed file type (based on the extension or other metadata) and the actual file type (based on the magic bytes and other structural characteristics).

<!-- Consider the following rule:

```
rule suspicious_pdf {
    condition:
        uint32(0) == 0x5A4D and
        filesize < 1MB and
        filename matches /.*\.pdf$/
}
```
This rule will match files that start with the PE magic bytes (indicating an executable), are less than 1MB in size and have a filename ending in .pdf. Such a file may be highly suspicious, as it claims to be a PDF (based on the extension) but is actually an executable. This technique of disguising malware as a benign file type is common and can be effectively detected using YARA rules that check for inconsistencies between the claimed file type (based on the extension or other metadata) and the actual file type (based on the magic bytes and other structural characteristics). -->

### Obfuscated URLs

Malware may use obfuscated URLs to hide the true destination of its network communication. These URLs might lead to command and control servers, malware download sites, or phishing pages. Obfuscation techniques can include:

- Encoding: The URL or parts of it might be encoded using URL encoding, base64, or other schemes.
- Randomization: The URL might include random strings to make it unique and evade simple string matching.
- Splitting: The URL might be split into multiple parts that are concatenated at runtime.

Here's an example of a YARA rule that detects obfuscated URLs:

```
rule obfuscated_url {
    strings:
        $regex_url = /http[s]?:\/\/[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,}\/[a-zA-Z0-9\/%&=\?_\-\.]+/ nocase
    condition:
        $regex_url and
        (#regex_url > 10
}
```

This rule uses a [regular expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions) $regex_url to match URLs. The nocase modifier makes the match case-insensitive. The condition checks for the presence of the URL pattern and then applies additional criteria:

- If there are more than 10 occurrences of the URL pattern (`#regex_url > 10`), it's considered suspicious. Malware often includes multiple redundant or backup URLs.
- If the entropy of the URL is high (`entropy($regex_url) > 5`), it's considered suspicious. High entropy can indicate the use of encoding or encryption to obfuscate the URL.

Malware can also use domain names with uncommon or suspicious top-level domains (TLDs) (it's the ".com" part of a web domain). These TLDs might be chosen because they are cheap, have lax registration policies, or are rarely used by legitimate websites. Examples of suspicious TLDs include .xyz, .top, .pw, .cc, .tk, among others:

```
rule suspicious_tlds {
    strings:
        $tld1 = ".xyz" nocase
        $tld2 = ".top" nocase
        $tld3 = ".pw" nocase
        $tld4 = ".cc" nocase
        $tld5 = ".tk" nocase
    condition:
        any of them
}
```

It's important to note that the presence of an obfuscated URL or a suspicious TLD doesn't necessarily mean that a file is malicious. There can be legitimate uses for these techniques. However, when combined with other indicators, they can help identify files that warrant further investigation.

### Suspicious Commands 

Malware often needs to execute commands on the infected system to perform various malicious actions, such as downloading additional malware, modifying system settings, or stealing data. To avoid detection, malware may attempt to execute these commands silently or with elevated privileges.


## 2. VirusTotal

VirusTotal is an online service that analyzes suspicious files and URLs to detect types of malware, including viruses, worms, and trojans. It uses a variety of tools, including YARA, to identify potential threats. VirusTotal also provides an API that allows users to automate the scanning process and integrate VirusTotal's capabilities into their own applications.

VirusTotal operates by taking a file or URL and running it through a suite of antivirus engines, website scanners, and other tools to detect any known malware signatures. The service aggregates the results from these tools to provide a comprehensive report on the file or URL's safety. This report includes information on the detection engines that flagged the file or URL, the type of malware detected (if any), and additional metadata about the file or URL.

For instance, when scanning a URL such as https://uwacyber.gitbook.io/cits2006, VirusTotal assesses the URL for potential security threats by utilizing its multiple antivirus engines and website scanners. Security vendors, which are companies that provide cybersecurity solutions and services, contribute to this analysis by using their own detection engines to evaluate the URL. The outcome of this scan is a detailed report that includes the security vendors' analysis, indicating whether any of the participating vendors have flagged the URL as malicious. Additionally, the report provides further web-related details, such as the detected content type, the last analysis date, and the status code returned by the server, which can be indicative of the website's current accessibility and health. In this case, the reports show that the website seems to be legitimate.

![Legitimate VirusTotal URL Scan](assets\lab4_img_2.png "Legitimate VirusTotal URL Scan")

We can scan suspicious URLs, such as those that appear in phishing email attempts, in the same way.

![Suspicious VirusTotal URL Scan](assets\lab4_img_3.png "Suspicious VirusTotal URL Scan")

### Task 2.1: Upload a Suspicious File to VirusTotal

Try uploading a few of the malware files from the `/opt/malware` to VirusTotal. What do the outputted reports tell you? Do you get different reports for different malwares?

### Task 2.2: Using the VirusTotal API

VirusTotal also offers an API that allows for automated interaction with their service without needing to use the webpage interface. The API enables you to upload and scan files, submit and scan URLs, access finished scan reports, and make automatic comments on URLs and samples. To use the VirusTotal API, you need to have an API key, which you can obtain by creating an account on the VirusTotal website. Once you have your API key, you can use it to make requests to the VirusTotal API to upload files for scanning, retrieve reports on files or URLs, and perform other operations supported by the API.

{% hint style="info" %}
Note the usage and rate limits applied to your access, which should be 4 lookups per minute on the free tier.
{% endhint %}

![VirusTotal API Key Page](assets\lab4_img_1.png "VirusTotal API Key Page")

In this task, you will write a script to upload a file to VirusTotal for scanning. This script will use the VirusTotal API to upload the file and then retrieve and display the scan results. Write a script in your chosen programming language that performs the following steps:

- Reads the file you want to scan.
- Makes an HTTP POST request to the VirusTotal API to upload the file for scanning.
- Retrieves the scan results using the API.
- Displays the scan results.

To get you started, the `virustotal_api.yar` file in the `/opt/scripts` directory can serve as a template in which you will complete the necessary code. Try your code out on some of the other malware samples in the `/opt/malware` directory and its subdirectories.

After running your script, you will receive a JSON response containing the scan results. This response includes information on the detection engines that flagged the file, the type of malware detected (if any), and additional metadata about the file. Examine the JSON response to understand the structure of the scan results. Pay special attention to the detection field, which contains the detection results from various engines. Based on the detection results, determine whether the file is likely to be malicious. Consider the number of engines that flagged the file and the types of malware detected.

### Task 2.3: Automating File Scanning

Now that you have a basic script for uploading a file to VirusTotal and retrieving the scan results, you can automate the scanning process for multiple files. Modify your script to accept a list of file paths and iterate over this list, uploading each file to VirusTotal and displaying the scan results. VirusTotal has a file size limit for uploads. If you encounter a file that exceeds this limit, your script should handle this gracefully, either by skipping the file or by splitting it into smaller parts for scanning.
